---
title: "Research Report"
author:
- name: Ihsan Kahveci
  affiliation: University of Washington
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: yes
    toc_float: yes
    code_folding: show
  word_document:
    toc: yes
subtitle: 'Network Frailty and Herd Immunity'
bibliography: references.bib
---

```{r setup, include=FALSE}
## Set knitr options here
knitr::opts_chunk$set(echo = FALSE,
                      comment = NA, 
                      cache = TRUE,
                      warning = FALSE,
                      message = FALSE, 
                      cache.lazy = FALSE
                      )

```

```{css, echo = FALSE}
caption {
      color: black;
      font-weight: bold;
      font-size: 1.0em;
}
```

```{r libraries, include=FALSE}
## Load libraries
library(sna)
library(dplyr)
library(purrr)
options(scipen = 999)
```

## Introduction


$$\bar{k} = \frac{\sum_i k_i}{n} =  \frac{2m}{n}$$

$$ d(G)^u = \bar{k} \times \frac{1}{n-1} =  \frac{\bar{k}}{n-1}$$
k:average degree, d:density

```{r}
set.seed(57)
size = 300
mean_degrees = 6:20 #100
total = length(mean_degrees)*100
densities = mean_degrees/(size-1)

```


```{r}
random_graphs = rgraph(n=size, m=total, mode="graph", tprob=densities, return.as.edgelist = TRUE)
names(random_graphs) <- paste0("network", 1:length(random_graphs))
```

```{r}
degree(random_graphs[1], gmode = "graph") %>% mean()
```


```{r}
hist(sapply(lapply(random_graphs, degree, gmode="graph"), mean), xlab="mean degree", main="")
```

```{r}
degree_attack <- function(g, inverse = FALSE){
  n = 300
  d = degree(g, gmode = "graph")
  if(inverse == FALSE) weights = d/sum(d)
  else weights = sum(d)/(d + 0.00000001)
  nodes = sample(n, n/2, prob = weights)
  for (node in nodes){
    inds = which(g[,1] == node)
    if(length(inds) == 0) next #in case the node has no edges
    ind = sample(inds, 1)
    if(length(ind) == 0) next 
    g = g[-c(ind, ind+1),]  #in most cases ind+1 is symmetric to ind
  }
  return(g)
}
  
```


Simulating degree attack both forwards and backwards

```{r}
out = lapply(random_graphs, degree_attack)
out_inverse = lapply(random_graphs, degree_attack, inverse = TRUE)
```

```{r}
out = lapply(out, network, directed=FALSE)
```



```{r}
x = 57
random_graphs[[x]] %>% dim() 
out[[x]] %>% dim()
out_inverse[[x]]  %>% dim()
```

Running community detection to find the bridge nodes.

```{r}
comps = component.dist(out)
comps_inv = component.dist(out_inverse)
```

```{r}
g = out[[1]]
colnames(g) = c("snd", "rec", "val")
```

```{r}
component.dist(g)
```

```{r}
sna::as.edgelist.sna(g)
```


```{r}
edgelist = out[[1000]]
test = network(edgelist, directed = FALSE) 
```


```{r}
component.dist(test)
```


Calculating the mean values  

```{r}
frailty = unlist(map_depth(comps, 2, mean)) 
cdist = names(frailty) %>% stringr::str_detect("cdist")
frailty = frailty[cdist]

frailty_inv = unlist(map_depth(comps_inv, 2, mean)) 
cdist_inv = names(frailty_inv) %>% stringr::str_detect("cdist")
frailty_inv = frailty_inv[cdist_inv]
```


```{r}
library(ggplot2)
library(tidyr)
tibble(id=1:1500,frailty, frailty_inv) %>%
  pivot_longer(-id) %>%
  ggplot(aes(value, fill=name)) + 
  geom_histogram(position = position_dodge())
```



## Code Appendix


```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}

```

## References

