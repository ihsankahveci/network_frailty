---
title: "Research Report"
author:
- name: Ihsan Kahveci
  affiliation: University of Washington
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: yes
    toc_float: yes
    code_folding: show
  word_document:
    toc: yes
subtitle: 'Network Frailty and Herd Immunity'
bibliography: references.bib
---

```{r setup, include=FALSE}
## Set knitr options here
knitr::opts_chunk$set(echo = FALSE,
                      comment = NA, 
                      cache = TRUE,
                      warning = FALSE,
                      message = FALSE, 
                      cache.lazy = FALSE
                      )

```

```{css, echo = FALSE}
caption {
      color: black;
      font-weight: bold;
      font-size: 1.0em;
}
```

```{r libraries, include=FALSE}
## Load libraries
library(sna)
library(dplyr)

```

## Introduction

```{r}
rgraph(10) # A uniform random digraph of order 10
rgraph(10, tprob=3/9) # Homogeneous Bernoulli w/mean degree 3
rgraph(10, tprob=3/9, mode="graph") # As above, but undirected
rgnm(1, 10, 20) # Uniform conditional on order, edges
rguman(1, 10, mut=0.5, asym=0.25, null=0.25) # Homogeneous multinomial on dyad census
rguman(1, 10, mut=0, asym=1, null=0) # An extreme case: random tournament
gplot(rgws(1,50,1,2,0)) # A Watts-Strogatz process - baseline
gplot(rgws(1,50,1,2,0.05)) # ...with rewiring probability 0.05
gplot(rgws(1,50,1,2,0.2)) # ...with rewiring probability 0.2

```

$$\bar{k} = \frac{\sum_i k_i}{n} =  \frac{2m}{n}$$

$$ d(G)^u = \bar{k} \times \frac{1}{n-1} =  \frac{\bar{k}}{n-1}$$
k:average degree, d:density

```{r}
n = 300
mean_degrees = 6:20
total = length(mean_degrees)*100
densities = mean_degrees/(n-1)

```


```{r}
random_graphs = rgraph(n=n, m=total, mode="graph", tprob=densities)
random_graphs = apply(random_graphs, 1, network)
names(random_graphs) <- paste0("network", 1:length(random_graphs))
```


```{r}
hist(sapply(lapply(random_graphs, degree, gmode="graph"), mean), xlab="mean degree", main="")
```

```{r}
degree_attack <- function(graphs, inverse = FALSE){
  i=1
  out = vector(mode = "list", length = length(graphs))
  for (g in graphs){
    n = network.size(g)
    degree = degree(g, gmode = "graph")
    if(inverse == FALSE){
      weights = degree/sum(degree)
    }else{
      weights = sum(degree)/(degree+0.001)
    }
    nodes = sample(1:n, n/4,  prob = weights)
    for (node in nodes){
      edges = get.edgeIDs(g, v = node)
      remove = sample(edges, size = 1)
      delete.edges(g, remove)
    }
    out[[i]] <- g
    i = i+1
  }
  names(out) = paste0("network", 1:length(graphs))
  return(out)
}
  
```


```{r}
out_inverse = degree_attack(random_graphs, inverse = TRUE)
```

```{r}
test = random_graphs[[3]]
```

```{r}
d = degree(test, gmode = "graph")
weights = sum(d)/(d+0.00000001)
nodes = sample(1:300, 10, prob = weights)
edges = get.edgeIDs(test, nodes[10])
remove = sample(edges, 1)
remove
```

```{r}
comps %>% unlist() %>% max()
```


## Code Appendix


```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}

```

## References

